<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Simple Rx Sample - UI Performance tuning | cdblg</title>
<meta name="keywords" content="">
<meta name="description" content="The case I&rsquo;m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.Here is a nice sample that demonstrate this case:I have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).This is the windowThis is the window xaml&lt;Window x:Class=&ldquo;ReactivlyPropertyChanged.MainWindow&rdquo;        xmlns=&ldquo;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;        xmlns:x=&ldquo;http://schemas.microsoft.com/winfx/2006/xaml&quot;        Title=&ldquo;MainWindow&rdquo; Height=&ldquo;350&rdquo; Width=&ldquo;525&rdquo; x:Name=&ldquo;this&rdquo;&gt;    &lt;Grid&gt;        &lt;StackPanel&gt;            &lt;TextBox Text=&quot;{Binding SomeText, ElementName=this, UpdateSourceTrigger=PropertyChanged}&rdquo;/&gt;            &lt;Button IsEnabled=&quot;{Binding ElementName=this, Path=CanSplitInMiddle}&quot;&gt;2&lt;/Button&gt;            &lt;Button IsEnabled=&quot;{Binding ElementName=this, Path=CanSplitToThreeParts}&quot;&gt;3&lt;/Button&gt;        &lt;/StackPanel&gt;    &lt;/Grid&gt;&lt;/Window&gt;This is the bounded properties implementation (I added sleep to demonstrate long time consumers)private string _someText;        public string SomeText        {            get { return _someText; }            set            {                _someText = value;                RaisePropertyChanged(&ldquo;SomeText&rdquo;);            }        }        public bool CanSplitInMiddle        {            get            {                if (SomeText == null)                    return false;                Thread.Sleep(100);                return SomeText.Length % 2 == 0;            }        }        public bool CanSplitToThreeParts        {            get            {                if (SomeText == null)                    return false;                Thread.Sleep(100);                return SomeText.Length % 3 == 0;            }        }As you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.Take a look at the property changed handling:public MainWindow(){    // Sets the buffer time for property changed    var interval = 500;    InitializeComponent();      // Create observable from the property changed event    var propertyChangedObservable =         Observable.FromEvent&lt;PropertyChangedEventArgs&gt;(this, &ldquo;PropertyChanged&rdquo;).        BufferWithTime(TimeSpan.FromMilliseconds(interval));      // Define our query from the event, we want to get all fired propertyChanged    var query = from changedProps in propertyChangedObservable                where changedProps.Count &gt; 0                 select changedProps;                                  // start listening    query.Subscribe(listOfChangedStuff =&gt;    {// When fired group all events by property name and handle each property with Changed method        var events = from distinctEvent in listOfChangedStuff                                 group distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName                                 select byPropertyName;        foreach (IGrouping&lt;string,IEvent&lt;PropertyChangedEventArgs&gt;&gt; groupedEvent in events)        {            Changed(groupedEvent.Key);        }    });        }public void Changed(string propertyName){    if (propertyName == &ldquo;SomeText&rdquo;)    {       // Make the properties recalculate themself        RaisePropertyChanged(&ldquo;CanSplitInMiddle&rdquo;);        RaisePropertyChanged(&ldquo;CanSplitToThreeParts&rdquo;);    }}public void RaisePropertyChanged(string propertyName){    var handlers = PropertyChanged;    if (handlers != null)    {        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));    }}So WTF?One of Rx many features is buffer,I can tell property changed event to buffer himself for some time, and when the time passed take all fired events and work with them, what I did is to group all events by the property name (like distinct in sql) and handled each group as a single event.So even if the user is a super turbo writer(or the bot that test the ui) , the event will fired only 2 times in a second, for 500 ms interval.I think this is awesome, you can configure the buffer interval according to how complex and time consuming your logic is, and avoid freezing ui.I wanted to upload the code to somewhere but o got to fly&hellip;">
<meta name="author" content="Chen Kinnrot">
<link rel="canonical" href="https://kinnrot.github.io/simple-rx-sample-ui-performance-tuning/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kinnrot.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kinnrot.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kinnrot.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kinnrot.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kinnrot.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://kinnrot.github.io/simple-rx-sample-ui-performance-tuning/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://kinnrot.github.io/simple-rx-sample-ui-performance-tuning/">
  <meta property="og:site_name" content="cdblg">
  <meta property="og:title" content="Simple Rx Sample - UI Performance tuning">
  <meta property="og:description" content="The case I’m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.
Here is a nice sample that demonstrate this case:
I have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).
This is the window
This is the window xaml
&lt;Window x:Class=“ReactivlyPropertyChanged.MainWindow”
xmlns=“http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;
xmlns:x=“http://schemas.microsoft.com/winfx/2006/xaml&#34;
Title=“MainWindow” Height=“350” Width=“525” x:Name=“this”&gt;
&lt;Grid&gt;
&lt;StackPanel&gt;
&lt;TextBox Text=&#34;{Binding SomeText, ElementName=this, UpdateSourceTrigger=PropertyChanged}”/&gt;
&lt;Button IsEnabled=&#34;{Binding ElementName=this, Path=CanSplitInMiddle}&#34;&gt;2&lt;/Button&gt;
&lt;Button IsEnabled=&#34;{Binding ElementName=this, Path=CanSplitToThreeParts}&#34;&gt;3&lt;/Button&gt;
&lt;/StackPanel&gt;
&lt;/Grid&gt;
&lt;/Window&gt;
This is the bounded properties implementation (I added sleep to demonstrate long time consumers)
private string _someText;
public string SomeText
{
get { return _someText; }
set
{
_someText = value;
RaisePropertyChanged(“SomeText”);
}
}
public bool CanSplitInMiddle
{
get
{
if (SomeText == null)
return false;
Thread.Sleep(100);
return SomeText.Length % 2 == 0;
}
}
public bool CanSplitToThreeParts
{
get
{
if (SomeText == null)
return false;
Thread.Sleep(100);
return SomeText.Length % 3 == 0;
}
}
As you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.
Take a look at the property changed handling:
public MainWindow()
{
// Sets the buffer time for property changed
var interval = 500;
InitializeComponent();
// Create observable from the property changed event
var propertyChangedObservable = Observable.FromEvent&lt;PropertyChangedEventArgs&gt;(this, “PropertyChanged”).
BufferWithTime(TimeSpan.FromMilliseconds(interval));
// Define our query from the event, we want to get all fired propertyChanged
var query = from changedProps in propertyChangedObservable
where changedProps.Count &gt; 0 select changedProps;
// start listening
query.Subscribe(listOfChangedStuff =&gt;
{
// When fired group all events by property name and handle each property with Changed method
var events = from distinctEvent in listOfChangedStuff
group distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName
select byPropertyName;
foreach (IGrouping&lt;string,IEvent&lt;PropertyChangedEventArgs&gt;&gt; groupedEvent in events)
{
Changed(groupedEvent.Key);
}
}); }
public void Changed(string propertyName)
{
if (propertyName == “SomeText”)
{
// Make the properties recalculate themself
RaisePropertyChanged(“CanSplitInMiddle”);
RaisePropertyChanged(“CanSplitToThreeParts”);
}
}
public void RaisePropertyChanged(string propertyName)
{
var handlers = PropertyChanged;
if (handlers != null)
{
PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
}
}
So WTF?
One of Rx many features is buffer,I can tell property changed event to buffer himself for some time, and when the time passed take all fired events and work with them, what I did is to group all events by the property name (like distinct in sql) and handled each group as a single event.
So even if the user is a super turbo writer(or the bot that test the ui) , the event will fired only 2 times in a second, for 500 ms interval.
I think this is awesome, you can configure the buffer interval according to how complex and time consuming your logic is, and avoid freezing ui.
I wanted to upload the code to somewhere but o got to fly…">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2010-09-14T14:43:00-07:00">
    <meta property="article:modified_time" content="2010-09-14T14:43:00-07:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple Rx Sample - UI Performance tuning">
<meta name="twitter:description" content="The case I&rsquo;m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.Here is a nice sample that demonstrate this case:I have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).This is the windowThis is the window xaml&lt;Window x:Class=&ldquo;ReactivlyPropertyChanged.MainWindow&rdquo;        xmlns=&ldquo;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;        xmlns:x=&ldquo;http://schemas.microsoft.com/winfx/2006/xaml&quot;        Title=&ldquo;MainWindow&rdquo; Height=&ldquo;350&rdquo; Width=&ldquo;525&rdquo; x:Name=&ldquo;this&rdquo;&gt;    &lt;Grid&gt;        &lt;StackPanel&gt;            &lt;TextBox Text=&quot;{Binding SomeText, ElementName=this, UpdateSourceTrigger=PropertyChanged}&rdquo;/&gt;            &lt;Button IsEnabled=&quot;{Binding ElementName=this, Path=CanSplitInMiddle}&quot;&gt;2&lt;/Button&gt;            &lt;Button IsEnabled=&quot;{Binding ElementName=this, Path=CanSplitToThreeParts}&quot;&gt;3&lt;/Button&gt;        &lt;/StackPanel&gt;    &lt;/Grid&gt;&lt;/Window&gt;This is the bounded properties implementation (I added sleep to demonstrate long time consumers)private string _someText;        public string SomeText        {            get { return _someText; }            set            {                _someText = value;                RaisePropertyChanged(&ldquo;SomeText&rdquo;);            }        }        public bool CanSplitInMiddle        {            get            {                if (SomeText == null)                    return false;                Thread.Sleep(100);                return SomeText.Length % 2 == 0;            }        }        public bool CanSplitToThreeParts        {            get            {                if (SomeText == null)                    return false;                Thread.Sleep(100);                return SomeText.Length % 3 == 0;            }        }As you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.Take a look at the property changed handling:public MainWindow(){    // Sets the buffer time for property changed    var interval = 500;    InitializeComponent();      // Create observable from the property changed event    var propertyChangedObservable =         Observable.FromEvent&lt;PropertyChangedEventArgs&gt;(this, &ldquo;PropertyChanged&rdquo;).        BufferWithTime(TimeSpan.FromMilliseconds(interval));      // Define our query from the event, we want to get all fired propertyChanged    var query = from changedProps in propertyChangedObservable                where changedProps.Count &gt; 0                 select changedProps;                                  // start listening    query.Subscribe(listOfChangedStuff =&gt;    {// When fired group all events by property name and handle each property with Changed method        var events = from distinctEvent in listOfChangedStuff                                 group distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName                                 select byPropertyName;        foreach (IGrouping&lt;string,IEvent&lt;PropertyChangedEventArgs&gt;&gt; groupedEvent in events)        {            Changed(groupedEvent.Key);        }    });        }public void Changed(string propertyName){    if (propertyName == &ldquo;SomeText&rdquo;)    {       // Make the properties recalculate themself        RaisePropertyChanged(&ldquo;CanSplitInMiddle&rdquo;);        RaisePropertyChanged(&ldquo;CanSplitToThreeParts&rdquo;);    }}public void RaisePropertyChanged(string propertyName){    var handlers = PropertyChanged;    if (handlers != null)    {        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));    }}So WTF?One of Rx many features is buffer,I can tell property changed event to buffer himself for some time, and when the time passed take all fired events and work with them, what I did is to group all events by the property name (like distinct in sql) and handled each group as a single event.So even if the user is a super turbo writer(or the bot that test the ui) , the event will fired only 2 times in a second, for 500 ms interval.I think this is awesome, you can configure the buffer interval according to how complex and time consuming your logic is, and avoid freezing ui.I wanted to upload the code to somewhere but o got to fly&hellip;">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kinnrot.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Simple Rx Sample - UI Performance tuning",
      "item": "https://kinnrot.github.io/simple-rx-sample-ui-performance-tuning/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Simple Rx Sample - UI Performance tuning",
  "name": "Simple Rx Sample - UI Performance tuning",
  "description": "The case I\u0026rsquo;m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.\nHere is a nice sample that demonstrate this case:\nI have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).\nThis is the window\nThis is the window xaml\n\u0026lt;Window x:Class=\u0026ldquo;ReactivlyPropertyChanged.MainWindow\u0026rdquo;\nxmlns=\u0026ldquo;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot;\nxmlns:x=\u0026ldquo;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot;\nTitle=\u0026ldquo;MainWindow\u0026rdquo; Height=\u0026ldquo;350\u0026rdquo; Width=\u0026ldquo;525\u0026rdquo; x:Name=\u0026ldquo;this\u0026rdquo;\u0026gt;\n\u0026lt;Grid\u0026gt;\n\u0026lt;StackPanel\u0026gt;\n\u0026lt;TextBox Text=\u0026quot;{Binding SomeText, ElementName=this, UpdateSourceTrigger=PropertyChanged}\u0026rdquo;/\u0026gt;\n\u0026lt;Button IsEnabled=\u0026quot;{Binding ElementName=this, Path=CanSplitInMiddle}\u0026quot;\u0026gt;2\u0026lt;/Button\u0026gt;\n\u0026lt;Button IsEnabled=\u0026quot;{Binding ElementName=this, Path=CanSplitToThreeParts}\u0026quot;\u0026gt;3\u0026lt;/Button\u0026gt;\n\u0026lt;/StackPanel\u0026gt;\n\u0026lt;/Grid\u0026gt;\n\u0026lt;/Window\u0026gt;\nThis is the bounded properties implementation (I added sleep to demonstrate long time consumers)\nprivate string _someText;\npublic string SomeText\n{\nget { return _someText; }\nset\n{\n_someText = value;\nRaisePropertyChanged(\u0026ldquo;SomeText\u0026rdquo;);\n}\n}\npublic bool CanSplitInMiddle\n{\nget\n{\nif (SomeText == null)\nreturn false;\nThread.Sleep(100);\nreturn SomeText.Length % 2 == 0;\n}\n}\npublic bool CanSplitToThreeParts\n{\nget\n{\nif (SomeText == null)\nreturn false;\nThread.Sleep(100);\nreturn SomeText.Length % 3 == 0;\n}\n}\nAs you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.\nTake a look at the property changed handling:\npublic MainWindow()\n{\n// Sets the buffer time for property changed\nvar interval = 500;\nInitializeComponent();\n// Create observable from the property changed event\nvar propertyChangedObservable = Observable.FromEvent\u0026lt;PropertyChangedEventArgs\u0026gt;(this, \u0026ldquo;PropertyChanged\u0026rdquo;).\nBufferWithTime(TimeSpan.FromMilliseconds(interval));\n// Define our query from the event, we want to get all fired propertyChanged\nvar query = from changedProps in propertyChangedObservable\nwhere changedProps.Count \u0026gt; 0 select changedProps;\n// start listening\nquery.Subscribe(listOfChangedStuff =\u0026gt;\n{\n// When fired group all events by property name and handle each property with Changed method\nvar events = from distinctEvent in listOfChangedStuff\ngroup distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName\nselect byPropertyName;\nforeach (IGrouping\u0026lt;string,IEvent\u0026lt;PropertyChangedEventArgs\u0026gt;\u0026gt; groupedEvent in events)\n{\nChanged(groupedEvent.Key);\n}\n}); }\npublic void Changed(string propertyName)\n{\nif (propertyName == \u0026ldquo;SomeText\u0026rdquo;)\n{\n// Make the properties recalculate themself\nRaisePropertyChanged(\u0026ldquo;CanSplitInMiddle\u0026rdquo;);\nRaisePropertyChanged(\u0026ldquo;CanSplitToThreeParts\u0026rdquo;);\n}\n}\npublic void RaisePropertyChanged(string propertyName)\n{\nvar handlers = PropertyChanged;\nif (handlers != null)\n{\nPropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n}\n}\nSo WTF?\nOne of Rx many features is buffer,I can tell property changed event to buffer himself for some time, and when the time passed take all fired events and work with them, what I did is to group all events by the property name (like distinct in sql) and handled each group as a single event.\nSo even if the user is a super turbo writer(or the bot that test the ui) , the event will fired only 2 times in a second, for 500 ms interval.\nI think this is awesome, you can configure the buffer interval according to how complex and time consuming your logic is, and avoid freezing ui.\nI wanted to upload the code to somewhere but o got to fly\u0026hellip;\n",
  "keywords": [
    
  ],
  "articleBody": "The case I’m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.\nHere is a nice sample that demonstrate this case:\nI have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).\nThis is the window\nThis is the window xaml\nhttp://schemas.microsoft.com/winfx/2006/xaml/presentation\"\nxmlns:x=“http://schemas.microsoft.com/winfx/2006/xaml\"\nTitle=“MainWindow” Height=“350” Width=“525” x:Name=“this”\u003e\n2\n3\nThis is the bounded properties implementation (I added sleep to demonstrate long time consumers)\nprivate string _someText;\npublic string SomeText\n{\nget { return _someText; }\nset\n{\n_someText = value;\nRaisePropertyChanged(“SomeText”);\n}\n}\npublic bool CanSplitInMiddle\n{\nget\n{\nif (SomeText == null)\nreturn false;\nThread.Sleep(100);\nreturn SomeText.Length % 2 == 0;\n}\n}\npublic bool CanSplitToThreeParts\n{\nget\n{\nif (SomeText == null)\nreturn false;\nThread.Sleep(100);\nreturn SomeText.Length % 3 == 0;\n}\n}\nAs you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.\nTake a look at the property changed handling:\npublic MainWindow()\n{\n// Sets the buffer time for property changed\nvar interval = 500;\nInitializeComponent();\n// Create observable from the property changed event\nvar propertyChangedObservable = Observable.FromEvent(this, “PropertyChanged”).\nBufferWithTime(TimeSpan.FromMilliseconds(interval));\n// Define our query from the event, we want to get all fired propertyChanged\nvar query = from changedProps in propertyChangedObservable\nwhere changedProps.Count \u003e 0 select changedProps;\n// start listening\nquery.Subscribe(listOfChangedStuff =\u003e\n{\n// When fired group all events by property name and handle each property with Changed method\nvar events = from distinctEvent in listOfChangedStuff\ngroup distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName\nselect byPropertyName;\nforeach (IGrouping",
  "wordCount" : "505",
  "inLanguage": "en",
  "datePublished": "2010-09-14T14:43:00-07:00",
  "dateModified": "2010-09-14T14:43:00-07:00",
  "author":{
    "@type": "Person",
    "name": "Chen Kinnrot"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kinnrot.github.io/simple-rx-sample-ui-performance-tuning/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cdblg",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kinnrot.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kinnrot.github.io/" accesskey="h" title="cdblg (Alt + H)">cdblg</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Simple Rx Sample - UI Performance tuning
    </h1>
    <div class="post-meta"><span title='2010-09-14 14:43:00 -0700 -0700'>September 14, 2010</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span>

</div>
  </header> 
  <div class="post-content"><p><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-size: 13px;"><span class="Apple-style-span" style="font-family: inherit;"><span class="Apple-style-span" style="font-size: medium;">The case I&rsquo;m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.</span></span></span></span><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">Here is a nice sample that demonstrate this case:</span><br /><span class="Apple-style-span" style="font-family: inherit;">I have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).</span><br /><span class="Apple-style-span" style="font-family: inherit;">This is the window</span><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_sNh3dtF9YE4/TI_igTblm9I/AAAAAAAACLw/k-zv0aBD_fM/s1600/Rx.bmp" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span class="Apple-style-span" style="font-family: inherit;"><img border="0" src="http://4.bp.blogspot.com/_sNh3dtF9YE4/TI_igTblm9I/AAAAAAAACLw/k-zv0aBD_fM/s320/Rx.bmp" /></span></a></div><span class="Apple-style-span" style="font-family: inherit;">This is the window xaml</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><pre class="brush: csharp;">&lt;Window x:Class=&ldquo;ReactivlyPropertyChanged.MainWindow&rdquo;<br />        xmlns=&ldquo;<a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation%22">http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</a><br />        xmlns:x=&ldquo;<a href="http://schemas.microsoft.com/winfx/2006/xaml%22">http://schemas.microsoft.com/winfx/2006/xaml&quot;</a><br />        Title=&ldquo;MainWindow&rdquo; Height=&ldquo;350&rdquo; Width=&ldquo;525&rdquo; x:Name=&ldquo;this&rdquo;&gt;<br />    &lt;Grid&gt;<br />        &lt;StackPanel&gt;<br />            &lt;TextBox Text=&quot;{Binding SomeText, ElementName=this, UpdateSourceTrigger=PropertyChanged}&rdquo;/&gt;<br />            &lt;Button IsEnabled=&quot;{Binding ElementName=this, Path=CanSplitInMiddle}&quot;&gt;2&lt;/Button&gt;<br />            &lt;Button IsEnabled=&quot;{Binding ElementName=this, Path=CanSplitToThreeParts}&quot;&gt;3&lt;/Button&gt;<br /><br />        &lt;/StackPanel&gt;<br />    &lt;/Grid&gt;<br />&lt;/Window&gt;</pre><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">This is the bounded properties implementation (I added sleep to demonstrate long time consumers)</span><br /><pre class="brush: csharp;">private string _someText;<br /><br />        public string SomeText<br />        {<br />            get { return _someText; }<br />            set<br />            {<br />                _someText = value;<br />                RaisePropertyChanged(&ldquo;SomeText&rdquo;);<br />            }<br />        }<br /><br />        public bool CanSplitInMiddle<br />        {<br />            get<br />            {<br />                if (SomeText == null)<br />                    return false;<br />                Thread.Sleep(100);<br />                return SomeText.Length % 2 == 0;<br />            }<br />        }<br /><br />        public bool CanSplitToThreeParts<br />        {<br />            get<br />            {<br />                if (SomeText == null)<br />                    return false;<br />                Thread.Sleep(100);<br />                return SomeText.Length % 3 == 0;<br />            }<br />        }<br /><br /></pre><span class="Apple-style-span" style="font-family: inherit;">As you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">Take a look at the property changed handling:</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><pre class="brush: csharp;">public MainWindow()<br />{<br />    // Sets the buffer time for property changed<br />    var interval = 500;<br /><br />    InitializeComponent();<br /><br />      // Create observable from the property changed event<br />    var propertyChangedObservable = <br />        Observable.FromEvent&lt;PropertyChangedEventArgs&gt;(this, &ldquo;PropertyChanged&rdquo;).<br />        BufferWithTime(TimeSpan.FromMilliseconds(interval));<br /><br />      // Define our query from the event, we want to get all fired propertyChanged<br />    var query = from changedProps in propertyChangedObservable<br />                where changedProps.Count &gt; 0 <br />                select changedProps;<br />                            <br />      // start listening<br />    query.Subscribe(listOfChangedStuff =&gt;<br />    {<br />// When fired group all events by property name and handle each property with Changed method<br />        var events = from distinctEvent in listOfChangedStuff<br />                                 group distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName<br />                                 select byPropertyName;<br /><br />        foreach (IGrouping&lt;string,IEvent&lt;PropertyChangedEventArgs&gt;&gt; groupedEvent in events)<br />        {<br />            Changed(groupedEvent.Key);<br />        }<br />    });        <br />}<br /><br />public void Changed(string propertyName)<br />{<br />    if (propertyName == &ldquo;SomeText&rdquo;)<br />    {<br />       // Make the properties recalculate themself<br />        RaisePropertyChanged(&ldquo;CanSplitInMiddle&rdquo;);<br />        RaisePropertyChanged(&ldquo;CanSplitToThreeParts&rdquo;);<br />    }<br />}<br /><br />public void RaisePropertyChanged(string propertyName)<br />{<br />    var handlers = PropertyChanged;<br />    if (handlers != null)<br />    {<br />        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));<br />    }<br />}<br /></pre><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">So WTF?</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">One of Rx many features is buffer,I can tell property changed event to buffer himself for some time, and when the time passed take all fired events and work with them, what I did is to group all events by the property name (like distinct in sql) and handled each group as a single event.</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">So even if the user is a super turbo writer(or the bot that test the ui) , the event will fired only 2 times in a second, for 500 ms interval.</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">I think this is awesome, you can configure the buffer interval according to how complex and time consuming your logic is, and avoid freezing ui.</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">I wanted to upload the code to somewhere but o got to fly&hellip;</span></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kinnrot.github.io/">cdblg</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
