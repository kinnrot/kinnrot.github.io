<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head>
	<meta name="generator" content="Hugo 0.155.3"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>cdblg</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://kinnrot.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kinnrot.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kinnrot.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kinnrot.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kinnrot.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kinnrot.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://kinnrot.github.io/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="https://kinnrot.github.io/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://kinnrot.github.io/">
  <meta property="og:site_name" content="cdblg">
  <meta property="og:title" content="cdblg">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cdblg">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "cdblg",
  "url": "https://kinnrot.github.io/",
  "description": "",
  "logo": "https://kinnrot.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kinnrot.github.io/" accesskey="h" title="cdblg (Alt + H)">cdblg</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Simple Rx Sample - UI Performance tuning
    </h2>
  </header>
  <div class="entry-content">
    <p>The case I’m talking about is Binding with the UpdateSourceTrigger = PropertyChanged, and a heavy logic behind each change that can cause bad UX, like ui freeze on each key press in a text box.
Here is a nice sample that demonstrate this case:
I have a window with a text box and 2 buttons, the IsEnabled of the buttons is bounded to custom properties that depends on the TextBox text bounded field to decide if the button should be enabled (just like commands).
This is the window
This is the window xaml
&lt;Window x:Class=“ReactivlyPropertyChanged.MainWindow”
xmlns=“http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;
xmlns:x=“http://schemas.microsoft.com/winfx/2006/xaml&#34;
Title=“MainWindow” Height=“350” Width=“525” x:Name=“this”&gt;
&lt;Grid&gt;
&lt;StackPanel&gt;
&lt;TextBox Text=&#34;{Binding SomeText, ElementName=this, UpdateSourceTrigger=PropertyChanged}”/&gt;
&lt;Button IsEnabled=&#34;{Binding ElementName=this, Path=CanSplitInMiddle}&#34;&gt;2&lt;/Button&gt;
&lt;Button IsEnabled=&#34;{Binding ElementName=this, Path=CanSplitToThreeParts}&#34;&gt;3&lt;/Button&gt;
&lt;/StackPanel&gt;
&lt;/Grid&gt;
&lt;/Window&gt;
This is the bounded properties implementation (I added sleep to demonstrate long time consumers)
private string _someText;
public string SomeText
{
get { return _someText; }
set
{
_someText = value;
RaisePropertyChanged(“SomeText”);
}
}
public bool CanSplitInMiddle
{
get
{
if (SomeText == null)
return false;
Thread.Sleep(100);
return SomeText.Length % 2 == 0;
}
}
public bool CanSplitToThreeParts
{
get
{
if (SomeText == null)
return false;
Thread.Sleep(100);
return SomeText.Length % 3 == 0;
}
}
As you can see there is a simple length check of the entered string, now you probably think that the application would get stuck for each key press for at least 200 ms.
Take a look at the property changed handling:
public MainWindow()
{
// Sets the buffer time for property changed
var interval = 500;
InitializeComponent();
// Create observable from the property changed event
var propertyChangedObservable = Observable.FromEvent&lt;PropertyChangedEventArgs&gt;(this, “PropertyChanged”).
BufferWithTime(TimeSpan.FromMilliseconds(interval));
// Define our query from the event, we want to get all fired propertyChanged
var query = from changedProps in propertyChangedObservable
where changedProps.Count &gt; 0 select changedProps;
// start listening
query.Subscribe(listOfChangedStuff =&gt;
{
// When fired group all events by property name and handle each property with Changed method
var events = from distinctEvent in listOfChangedStuff
group distinctEvent by distinctEvent.EventArgs.PropertyName into byPropertyName
select byPropertyName;
foreach (IGrouping&lt;string,IEvent&lt;PropertyChangedEventArgs&gt;&gt; groupedEvent in events)
{
Changed(groupedEvent.Key);
}
}); }
public void Changed(string propertyName)
{
if (propertyName == “SomeText”)
{
// Make the properties recalculate themself
RaisePropertyChanged(“CanSplitInMiddle”);
RaisePropertyChanged(“CanSplitToThreeParts”);
}
}
public void RaisePropertyChanged(string propertyName)
{
var handlers = PropertyChanged;
if (handlers != null)
{
PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
}
}
So WTF?
One of Rx many features is buffer,I can tell property changed event to buffer himself for some time, and when the time passed take all fired events and work with them, what I did is to group all events by the property name (like distinct in sql) and handled each group as a single event.
So even if the user is a super turbo writer(or the bot that test the ui) , the event will fired only 2 times in a second, for 500 ms interval.
I think this is awesome, you can configure the buffer interval according to how complex and time consuming your logic is, and avoid freezing ui.
I wanted to upload the code to somewhere but o got to fly…
</p>
  </div>
  <footer class="entry-footer"><span title='2010-09-14 14:43:00 -0700 -0700'>September 14, 2010</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span></footer>
  <a class="entry-link" aria-label="post link to Simple Rx Sample - UI Performance tuning" href="https://kinnrot.github.io/simple-rx-sample-ui-performance-tuning/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">For AMT Rx for .net
    </h2>
  </header>
  <div class="entry-content">
    <p>Here is a good place to start with Rx for .net
And here you have the wiki with examples
Enjoy!
</p>
  </div>
  <footer class="entry-footer"><span title='2010-09-06 09:26:00 -0700 -0700'>September 6, 2010</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span></footer>
  <a class="entry-link" aria-label="post link to For AMT Rx for .net" href="https://kinnrot.github.io/for-amt-rx-for-net/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">WCF client side proxy memory leaks
    </h2>
  </header>
  <div class="entry-content">
    <p>Today I ran into a guy who worked with me on my previous project.
On that project I was responsible to rewrite the WCF channels (proxies) generation management and lifetime management of them.
I decided to do some research and found some good stuff here.
So this guy (aka Kurki) tells me they found a memory leak in my manager, what was the problem?
So i messed up like I always do (well, only 90% of the time, like a good programmer).
I wrote a code that registers to the Faulted event of the channel, kills the channel when Faulted and creates a new one to work with, everything looked fine, only one screw up (I’m sure some of you can guess).
I forgot to unregister from the Faulted Event.
On the web they tell you to do some unique logic to kill your channel in a safe way, what they don’t talk about is that it’ll stay in memory and fire events if you won’t unregister from stuff although you think it is dead.
So please do not forget to unregister from stuff even if the object is disposable.
Or consider the use of weak event listeners and problem solved.
</p>
  </div>
  <footer class="entry-footer"><span title='2010-09-02 12:34:00 -0700 -0700'>September 2, 2010</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span></footer>
  <a class="entry-link" aria-label="post link to WCF client side proxy memory leaks" href="https://kinnrot.github.io/wcf-client-side-proxy-memory-leaks/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Unit Test PropertyChanged
    </h2>
  </header>
  <div class="entry-content">
    <p>One of the basic stuff you wanna test as a client side developer, is that all of your UI bounded classes aka Controller, Model, ViewModel, Presenter, PresentationModel, or the code behind of your view if your just having fun.
Let’s assume we have a person class with a name property:
public class Person : INotifyPropertyChanged
{
public event PropertyChangedEventHandler PropertyChanged;
private string _name;
public virtual string Name
{
get { return _name; }
set { _name = value;
FirePropertyChanged(“Name”);
}
}
protected virtual void FirePropertyChanged(string propertyName)
{
var handlers = PropertyChanged;
if (handlers != null)
{
handlers(this, new PropertyChangedEventArgs(propertyName));
}
}
}
The simplest way to perform this test is to write this code:
[TestFixture]
public class PersonTest
{
[Test]
public void SetName_SomeNewString_FirePropertyChanged()
{
Person person = new Person();
string changedPropertyName = string.Empty;
person.PropertyChanged &#43;= (sender, args) =&gt; changedPropertyName = args.PropertyName;
person.Name = “Test”;
Assert.AreEqual(“Name”, changedPropertyName);
}
}
</p>
  </div>
  <footer class="entry-footer"><span title='2010-09-01 15:01:00 -0700 -0700'>September 1, 2010</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span></footer>
  <a class="entry-link" aria-label="post link to Unit Test PropertyChanged" href="https://kinnrot.github.io/unit-test-propertychanged/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Hello World
    </h2>
  </header>
  <div class="entry-content">
    <p>public class Chen
{
public void SayHello()
{
Console.WriteLine(&#34;Hello everyone! this is my first blog post, its about time&#34;);
}
}
</p>
  </div>
  <footer class="entry-footer"><span title='2010-09-01 08:23:00 -0700 -0700'>September 1, 2010</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span></footer>
  <a class="entry-link" aria-label="post link to Hello World" href="https://kinnrot.github.io/hello-world/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://kinnrot.github.io/page/6/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kinnrot.github.io/">cdblg</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
