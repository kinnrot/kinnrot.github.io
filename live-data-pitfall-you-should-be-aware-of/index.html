<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Live Data Pitfall You Should Be Aware Of | cdblg</title>
<meta name="keywords" content="android, arch, lifecycle">
<meta name="description" content="When working with MutableLiveData you can update the observable value in 2 ways:

setValue
postValue

Both will update the live data value as expected as long as your code is running from the main thread.
If you need to update a value from other thread you can use the postValue which is thread safe, and will make sure to notify observers on main thread.
This is all nice, but be aware!">
<meta name="author" content="Chen Kinnrot">
<link rel="canonical" href="https://kinnrot.github.io/live-data-pitfall-you-should-be-aware-of/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kinnrot.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kinnrot.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kinnrot.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kinnrot.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kinnrot.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://kinnrot.github.io/live-data-pitfall-you-should-be-aware-of/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://kinnrot.github.io/live-data-pitfall-you-should-be-aware-of/">
  <meta property="og:site_name" content="cdblg">
  <meta property="og:title" content="Live Data Pitfall You Should Be Aware Of">
  <meta property="og:description" content="When working with MutableLiveData you can update the observable value in 2 ways:
setValue postValue Both will update the live data value as expected as long as your code is running from the main thread.
If you need to update a value from other thread you can use the postValue which is thread safe, and will make sure to notify observers on main thread.
This is all nice, but be aware!">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-10-22T08:12:18+03:00">
    <meta property="article:modified_time" content="2018-10-22T08:12:18+03:00">
    <meta property="article:tag" content="Android">
    <meta property="article:tag" content="Arch">
    <meta property="article:tag" content="Lifecycle">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Live Data Pitfall You Should Be Aware Of">
<meta name="twitter:description" content="When working with MutableLiveData you can update the observable value in 2 ways:

setValue
postValue

Both will update the live data value as expected as long as your code is running from the main thread.
If you need to update a value from other thread you can use the postValue which is thread safe, and will make sure to notify observers on main thread.
This is all nice, but be aware!">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kinnrot.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Live Data Pitfall You Should Be Aware Of",
      "item": "https://kinnrot.github.io/live-data-pitfall-you-should-be-aware-of/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Live Data Pitfall You Should Be Aware Of",
  "name": "Live Data Pitfall You Should Be Aware Of",
  "description": "When working with MutableLiveData you can update the observable value in 2 ways:\nsetValue postValue Both will update the live data value as expected as long as your code is running from the main thread.\nIf you need to update a value from other thread you can use the postValue which is thread safe, and will make sure to notify observers on main thread.\nThis is all nice, but be aware!\n",
  "keywords": [
    "android", "arch", "lifecycle"
  ],
  "articleBody": "When working with MutableLiveData you can update the observable value in 2 ways:\nsetValue postValue Both will update the live data value as expected as long as your code is running from the main thread.\nIf you need to update a value from other thread you can use the postValue which is thread safe, and will make sure to notify observers on main thread.\nThis is all nice, but be aware!\nval foo = MutableLiveData() // this foo.value = true foo.value = false // and that foo.postValue(true) foo.postValue(false) Both this and that sets the live data value to true and then to false, so you probably expect, if observing foo, you’ll get your code to run twice, once with true and once with false.\nWell for the first section with setValue it works as expected.\nFor the second section with postValue you’ll get a surprise, only second call triggers the observer, or is it?\nThe issue with post value is as follows:\nValue is being set immediately in a synchronized code block for thread safety, but the observers notification is scheduled to execute on main thread via the event loop (with handler) So whats happening is value changes to true and false but scheduling code occurs only once.\nthis is the implementation of postValue\nprotected void postValue(T value) { boolean postTask; synchronized (mDataLock) { postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { return; } ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); } As you can postTask is a flag that say “do I need to schedule a runnable to notify my observers, or did I already do that?” for the first call postTask is true, and for the second its false\npostValue is good for ui progress reporting for example, cause ui updates only when main thread is available to perform screen updates. It’s not good when you count on getting notified for each change of the LiveDataValue.\nas comment says:\nIf you called this method multiple times before a main thread executed a posted task, only the last value would be dispatched.\nSo I recommend, by default, prefer using setValue, use postValue, only when:\nyou gonna post lots of changes (progress) and you don’t need all of them only last value is relevant. you not running on the main thread. ",
  "wordCount" : "379",
  "inLanguage": "en",
  "datePublished": "2018-10-22T08:12:18+03:00",
  "dateModified": "2018-10-22T08:12:18+03:00",
  "author":{
    "@type": "Person",
    "name": "Chen Kinnrot"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kinnrot.github.io/live-data-pitfall-you-should-be-aware-of/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cdblg",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kinnrot.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kinnrot.github.io/" accesskey="h" title="cdblg (Alt + H)">cdblg</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Live Data Pitfall You Should Be Aware Of
    </h1>
    <div class="post-meta"><span title='2018-10-22 08:12:18 +0300 IDT'>October 22, 2018</span>&nbsp;·&nbsp;<span>Chen Kinnrot</span>

</div>
  </header> 
  <div class="post-content"><p>When working with <code>MutableLiveData</code> you can update the observable value in 2 ways:</p>
<ol>
<li><code>setValue</code></li>
<li><code>postValue</code></li>
</ol>
<p>Both will update the live data value as expected as long as your code is running from the main thread.</p>
<p>If you need to update a value from other thread you can use the <code>postValue</code> which is thread safe, and will make sure to notify observers on main thread.</p>
<p>This is all nice, but be aware!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> foo = MutableLiveData&lt;Boolean&gt;()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// this
</span></span></span><span style="display:flex;"><span>foo.<span style="color:#66d9ef">value</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>foo.<span style="color:#66d9ef">value</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// and that
</span></span></span><span style="display:flex;"><span>foo.postValue(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>foo.postValue(<span style="color:#66d9ef">false</span>)
</span></span></code></pre></div><p>Both this and that sets the live data value to true and then to false, so you probably expect, if observing foo, you&rsquo;ll get your code to run twice,
once with true and once with false.</p>
<p>Well for the first section with <code>setValue</code> it works as expected.</p>
<p>For the second section with <code>postValue</code> you&rsquo;ll get a surprise, only second call triggers the observer, or is it?</p>
<p>The issue with post value is as follows:</p>
<p>Value is being set immediately in a synchronized code block for thread safety,
but the observers notification is scheduled to execute on main thread via the event loop (with handler)
So whats happening is value changes to true and false but scheduling code occurs only once.</p>
<p>this is the implementation of <code>postValue</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> void postValue(T <span style="color:#66d9ef">value</span>) {
</span></span><span style="display:flex;"><span>   boolean postTask;
</span></span><span style="display:flex;"><span>   synchronized (mDataLock) {
</span></span><span style="display:flex;"><span>       postTask = mPendingData <span style="color:#f92672">==</span> NOT_SET;
</span></span><span style="display:flex;"><span>       mPendingData = <span style="color:#66d9ef">value</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (!postTask) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ArchTaskExecutor</span>.getInstance().postToMainThread(mPostValueRunnable);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can <code>postTask</code> is a flag that say &ldquo;do I need to schedule a runnable to notify my observers, or did I already do that?&rdquo;
for the first call <code>postTask</code> is true, and for the second its false</p>
<p>postValue is good for ui progress reporting for example, cause ui updates only when main thread is available to perform screen updates.
It&rsquo;s not good when you count on getting notified for each change of the LiveDataValue.</p>
<p>as comment says:</p>
<blockquote>
<p>If you called this method multiple times before a main thread executed a posted task, only the last value would be dispatched.</p>
</blockquote>
<p>So I recommend, by default, prefer using <code>setValue</code>, use postValue, only when:</p>
<ol>
<li>you gonna post lots of changes (progress) and you don&rsquo;t need all of them only last value is relevant.</li>
<li>you not running on the main thread.</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kinnrot.github.io/tags/android/">Android</a></li>
      <li><a href="https://kinnrot.github.io/tags/arch/">Arch</a></li>
      <li><a href="https://kinnrot.github.io/tags/lifecycle/">Lifecycle</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kinnrot.github.io/">cdblg</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
