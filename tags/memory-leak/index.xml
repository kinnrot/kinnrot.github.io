<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Memory Leak on cdblg</title>
    <link>https://kinnrot.github.io/tags/memory-leak/</link>
    <description>Recent content in Memory Leak on cdblg</description>
    <generator>Hugo -- 0.155.3</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Jun 2017 05:11:00 -0700</lastBuildDate>
    <atom:link href="https://kinnrot.github.io/tags/memory-leak/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ruby Lazy chunked hash like behavior</title>
      <link>https://kinnrot.github.io/ruby-lazy-chunked-hash-like-behavior/</link>
      <pubDate>Mon, 05 Jun 2017 05:11:00 -0700</pubDate>
      <guid>https://kinnrot.github.io/ruby-lazy-chunked-hash-like-behavior/</guid>
      <description>&lt;p&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;When we want to iterate a long list, we can simply write a query and get a cursor, ActiveRecord will do all the heavy lifting for us.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;What happens when we need to do some complicated computations on a set of data, which sometimes can be too big to be stored in memory for the entire computing process?&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;This is when we need to start being more creational.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;I&amp;rsquo;d like to introduce what I came up with.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;The problem:&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;- Complex calculation on time based data series for a period of 3 months.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;- Each calculation may depends on previous one and on future and past data.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;- Must be in order.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;- When fetching all data server crash on memory.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;The solution:&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;I wanted to do the most minor code change possible, and currently the data was accessed via a hash. &lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;I decided to encapsulate the hash with something I called lazy chunked hash (tried google it see it as standard behavior in clojure).&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;It looks like this:&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;pre style=&#34;background-color: #2b2b2b; color: #e6e1dc; font-family: &#39;mononoki&#39;; font-size: 11.3pt;&#34;&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;class &lt;/span&gt;&lt;span style=&#34;color: white;&#34;&gt;ValuesProvider&lt;/span&gt;&lt;span style=&#34;color: white;&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;def &lt;/span&gt;&lt;span style=&#34;color: #ffc66d;&#34;&gt;initialize&lt;/span&gt;()&lt;br /&gt;    &lt;span style=&#34;color: #d0d0ff;&#34;&gt;@loaded_date &lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;= nil&lt;/span&gt;&lt;/pre&gt;&lt;pre style=&#34;background-color: #2b2b2b; color: #e6e1dc; font-family: &#39;mononoki&#39;; font-size: 11.3pt;&#34;&gt;&lt;pre style=&#34;font-family: mononoki; font-size: 11.3pt;&#34;&gt;&lt;span style=&#34;background-color: #3c3c57; color: #d0d0ff;&#34;&gt;    @hash&lt;/span&gt;&lt;span style=&#34;color: #d0d0ff;&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;= &lt;/span&gt;&lt;span style=&#34;color: #6d9cbe;&#34;&gt;Hash&lt;/span&gt;.new(&lt;span style=&#34;color: #a5c261;&#34;&gt;0&lt;/span&gt;)&lt;/pre&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;  end&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;  def &lt;/span&gt;&lt;span style=&#34;color: #ffc66d;&#34;&gt;[]&lt;/span&gt;(time_slot)     get(time_slot)   &lt;span style=&#34;color: #cc7833;&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;  private&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;  def &lt;/span&gt;&lt;span style=&#34;color: #ffc66d;&#34;&gt;get&lt;/span&gt;(time_slot)     &lt;span style=&#34;color: #d0d0ff;&#34;&gt;relevant_date &lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;= &lt;/span&gt;time_slot.to_date     &lt;span style=&#34;color: #cc7833;&#34;&gt;unless &lt;/span&gt;&lt;span style=&#34;color: #d0d0ff;&#34;&gt;relevant_date &lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;== &lt;/span&gt;&lt;span style=&#34;color: #d0d0ff;&#34;&gt;@loaded_date&lt;/span&gt;&lt;span style=&#34;color: #d0d0ff;&#34;&gt;      &lt;/span&gt;load(&lt;span style=&#34;color: #d0d0ff;&#34;&gt;relevant_date&lt;/span&gt;)     &lt;span style=&#34;color: #cc7833;&#34;&gt;end&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #d0d0ff;&#34;&gt;@hash&lt;/span&gt;[time_slot.to_i]   &lt;span style=&#34;color: #cc7833;&#34;&gt;end&lt;/span&gt;&lt;/pre&gt;&lt;pre style=&#34;background-color: #2b2b2b; color: #e6e1dc; font-family: &#39;mononoki&#39;; font-size: 11.3pt;&#34;&gt;&lt;span style=&#34;color: #cc7833;&#34;&gt;end&lt;/span&gt;&lt;/pre&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;Pretty simple and does the work, instead of loading the data all at once, the data is being loaded for each day separately, this way we keep it chunky but not too chunky.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;And best part, my code that consume the data, didn&amp;rsquo;t change because of the [] method, which makes my ValueProvider behave like an array. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style=&#34;font-family: Courier New, Courier, monospace;&#34;&gt;This solution is good when the consumer data request(call for[]) implies on what data should be loaded, which most of the times will, but in some cases it won&amp;rsquo;t)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rubymine on OSX memory issues</title>
      <link>https://kinnrot.github.io/rubymine-on-osx/</link>
      <pubDate>Tue, 06 Jan 2015 13:32:00 -0800</pubDate>
      <guid>https://kinnrot.github.io/rubymine-on-osx/</guid>
      <description>&lt;p&gt;I found this only today, you should run Rubymine as 32 bit process.&lt;br /&gt;It works much faster and consume half the memory.&lt;br /&gt;&lt;br /&gt;To set this got to the Applicaitons folder right click on rubymine-&amp;gt;get info and check the &amp;ldquo;open in 32 bit mode&amp;rdquo;&lt;br /&gt;&lt;br /&gt;Thats all!&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>WCF client side proxy memory leaks</title>
      <link>https://kinnrot.github.io/wcf-client-side-proxy-memory-leaks/</link>
      <pubDate>Thu, 02 Sep 2010 12:34:00 -0700</pubDate>
      <guid>https://kinnrot.github.io/wcf-client-side-proxy-memory-leaks/</guid>
      <description>&lt;p&gt;Today I ran into a guy who worked with me on my previous project.&lt;br /&gt;On that project I was responsible to rewrite the WCF channels (proxies) generation management and lifetime management of them.&lt;br /&gt;I decided to do some research and found some good stuff &lt;a href=&#34;http://wcfguidanceforwpf.codeplex.com/&#34;&gt;here&lt;/a&gt;.&lt;br /&gt;So this guy (aka Kurki) tells me they found a memory leak in my manager, what was the problem?&lt;br /&gt;&lt;br /&gt;So i messed up like I always do (well, only 90% of the time, like a good programmer).&lt;br /&gt;&lt;br /&gt;I wrote a code that registers to the Faulted event of the channel, kills the channel when Faulted and creates a new one to work with, everything looked fine, only one screw up (I&amp;rsquo;m sure some of you can guess).&lt;br /&gt;I forgot to unregister from the Faulted Event.&lt;br /&gt;&lt;br /&gt;On the web they tell you to do some unique logic to kill your channel in a safe way, what they don&amp;rsquo;t talk about is that it&amp;rsquo;ll stay in memory and fire events if you won&amp;rsquo;t unregister from stuff although you think it is dead.&lt;br /&gt;&lt;br /&gt;So please &lt;u&gt;do not forget to unregister from stuff even if the object is disposable&lt;/u&gt;.&lt;br /&gt;&lt;br /&gt;Or consider the use of weak event listeners and problem solved.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
