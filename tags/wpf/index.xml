<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WPF on cdblg</title>
    <link>https://kinnrot.github.io/tags/wpf/</link>
    <description>Recent content in WPF on cdblg</description>
    <generator>Hugo -- 0.155.3</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Jan 2011 14:47:00 -0800</lastBuildDate>
    <atom:link href="https://kinnrot.github.io/tags/wpf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WPF Binding and Why you should write defensive code.</title>
      <link>https://kinnrot.github.io/wpf-binding-and-why-you-should-write/</link>
      <pubDate>Wed, 05 Jan 2011 14:47:00 -0800</pubDate>
      <guid>https://kinnrot.github.io/wpf-binding-and-why-you-should-write/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m overriding equals and implementing IEquatable on some of my objects and bind them as an ObservableCollection to the UI.&lt;br /&gt;&lt;br /&gt;Here is a sample: (ugly code do not use)&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#34;brush: csharp;&#34;&gt;&amp;lt;Window x:Class=&amp;ldquo;BindingToItemsWithIEquality.MainWindow&amp;rdquo;&lt;br /&gt;        xmlns=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&lt;/a&gt;&lt;br /&gt;        xmlns:x=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&lt;/a&gt;&lt;br /&gt;        xmlns:local=&amp;ldquo;clr-namespace:BindingToItemsWithIEquality&amp;rdquo;&lt;br /&gt;        Title=&amp;ldquo;MainWindow&amp;rdquo; Height=&amp;ldquo;350&amp;rdquo; Width=&amp;ldquo;525&amp;rdquo;&lt;br /&gt;        &amp;gt;&lt;br /&gt;    &amp;lt;Window.DataContext&amp;gt;&lt;br /&gt;        &amp;lt;local:SomeContextWithCollection/&amp;gt;&lt;br /&gt;    &amp;lt;/Window.DataContext&amp;gt;&lt;br /&gt;    &amp;lt;StackPanel&amp;gt;&lt;br /&gt;        &amp;lt;ListBox DisplayMemberPath=&amp;ldquo;Name&amp;rdquo; ItemsSource=&amp;quot;{Binding Items}&amp;rdquo;/&amp;gt;&lt;br /&gt;        &amp;lt;Button Click=&amp;ldquo;Button_Click&amp;rdquo;&amp;gt;clear&amp;lt;/Button&amp;gt;&lt;br /&gt;    &amp;lt;/StackPanel&amp;gt;&lt;br /&gt;&amp;lt;/Window&amp;gt;&lt;br /&gt;&lt;br /&gt;//code behind&lt;br /&gt;private void Button_Click(object sender, RoutedEventArgs e)&lt;br /&gt;{&lt;br /&gt;  (this.DataContext as SomeContextWithCollection).Items.Clear();&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public class SomeContextWithCollection &lt;br /&gt;{&lt;br /&gt;    public ObservableCollection&amp;lt;SomeIEqutable&amp;gt; Items { get; set; }&lt;br /&gt;&lt;br /&gt;    public SomeContextWithCollection()&lt;br /&gt;    {&lt;br /&gt;      Items = new ObservableCollection&amp;lt;SomeIEqutable&amp;gt;();&lt;br /&gt;      Items.Add(new SomeIEqutable() { Name = &amp;ldquo;1&amp;rdquo; });&lt;br /&gt;      Items.Add(new SomeIEqutable() { Name = &amp;ldquo;2&amp;rdquo; });&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public class SomeIEqutable : IEquatable&amp;lt;SomeIEqutable&amp;gt;&lt;br /&gt;{&lt;br /&gt;  public string Name { get; set; }&lt;br /&gt;&lt;br /&gt;  public override bool Equals(object obj)&lt;br /&gt;  {&lt;br /&gt;    if (obj == null)&lt;br /&gt;    {&lt;br /&gt;      return false;&lt;br /&gt;    }&lt;br /&gt;          &lt;br /&gt;    return Equals((SomeIEqutable)obj);&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  public bool Equals(SomeIEqutable other)&lt;br /&gt;  {&lt;br /&gt;    if (object.ReferenceEquals(this, other))&lt;br /&gt;    {&lt;br /&gt;      return true;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    return Name == other.Name;&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  public override int GetHashCode()&lt;br /&gt;  {&lt;br /&gt;    return Name.GetHashCode();&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When calling collection.Clear() I get an invalid cast inside my equals method, when trying to cast to SomeIEquatable.&lt;br /&gt;&lt;br /&gt;This is pretty strange, object is not null and not SomeIEquatlabe, how did it get to my Equals?&lt;br /&gt;&lt;br /&gt;The answer is WPF, when working with binding and clearing a bounded collection WPF will compare his internal new MSInternal.NamedObject(named DisconnectedItem) to your SomeIEquatable object and will fail if you try to implicitly cast it to your type.&lt;br /&gt;&lt;br /&gt;The simple solution is to use the &amp;ldquo;as&amp;rdquo; keyword istead of cast.&lt;br /&gt;&lt;br /&gt;If my code didn&amp;rsquo;t smell from the start, I would never got to this dark place. But I&amp;rsquo;m glad it happened, now I have another excuse to write defensive code.&lt;/p&gt;</description>
    </item>
    <item>
      <title>What do you think?</title>
      <link>https://kinnrot.github.io/what-do-you-think/</link>
      <pubDate>Wed, 05 Jan 2011 13:12:00 -0800</pubDate>
      <guid>https://kinnrot.github.io/what-do-you-think/</guid>
      <description>&lt;p&gt;About a year ago I asked the following question&lt;br /&gt; &lt;div id=&#34;stacktack-1114555&#34;&gt;&lt;/div&gt;This week I got one more answer and I wanna ask you guys what do you think is the best practice?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simple way to avoid hard coded strings in xaml</title>
      <link>https://kinnrot.github.io/simple-way-to-avoid-hard-coded-strings/</link>
      <pubDate>Mon, 03 Jan 2011 11:20:00 -0800</pubDate>
      <guid>https://kinnrot.github.io/simple-way-to-avoid-hard-coded-strings/</guid>
      <description>&lt;p&gt;Hard coded strings are annoying,&lt;br /&gt;In XAML, we have a lot of cases of hard coded strings.&lt;br /&gt;&lt;br /&gt;Here is a simple way of implementing static naming class, and use it instead of hard coded strings.&lt;br /&gt;&lt;br /&gt;Suppose this is my xaml:&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#34;brush: csharp;&#34;&gt;&amp;lt;Window x:Class=&amp;ldquo;How.MainWindow&amp;rdquo;&lt;br /&gt;        xmlns=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&lt;/a&gt;&lt;br /&gt;        xmlns:x=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&lt;/a&gt;&lt;br /&gt;        xmlns:local=&amp;ldquo;clr-namespace:How&amp;rdquo;&lt;br /&gt;        Title=&amp;ldquo;MainWindow&amp;rdquo; Height=&amp;ldquo;350&amp;rdquo; Width=&amp;ldquo;525&amp;rdquo;&amp;gt;&lt;br /&gt;    &amp;lt;Window.Resources&amp;gt;&lt;br /&gt;        &amp;lt;Style TargetType=&amp;quot;{x:Type Button}&amp;rdquo; x:Key=&amp;ldquo;LazyGuyMeaninglessName&amp;rdquo;&amp;gt;&lt;br /&gt;            &amp;lt;Setter Property=&amp;ldquo;Margin&amp;rdquo; Value=&amp;ldquo;30&amp;rdquo;/&amp;gt;&lt;br /&gt;            &amp;lt;Setter Property=&amp;ldquo;Height&amp;rdquo; Value=&amp;ldquo;30&amp;rdquo;/&amp;gt;&lt;br /&gt;            &amp;lt;Setter Property=&amp;ldquo;Width&amp;rdquo; Value=&amp;ldquo;200&amp;rdquo;/&amp;gt;&lt;br /&gt;        &amp;lt;/Style&amp;gt;&lt;br /&gt;    &amp;lt;/Window.Resources&amp;gt;&lt;br /&gt;    &amp;lt;StackPanel&amp;gt;&lt;br /&gt;            &amp;lt;Button Click=&amp;ldquo;Button_Click&amp;rdquo;&amp;gt;Click me to activate my style&amp;lt;/Button&amp;gt;&lt;br /&gt;        &amp;lt;Button Style=&amp;quot;{DynamicResource LazyGuyMeaninglessName}&amp;rdquo;/&amp;gt;&lt;br /&gt;    &amp;lt;/StackPanel&amp;gt;&lt;br /&gt;&amp;lt;/Window&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;This is code behind:&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#34;brush: csharp;&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)&lt;br /&gt;{&lt;br /&gt;  var button = sender as Button;&lt;br /&gt;  if (button != null)&lt;br /&gt;  {&lt;br /&gt;    button.Style = (Style)this.FindResource(&amp;ldquo;LazyGuyMeaninglessNameWithMistake&amp;rdquo;);&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;I have a mistake in my code behind, and the program will crash, not so fun, and not simple to test this kind of stuff.&lt;br /&gt;&lt;br /&gt;There is a very simple solution, Lets define this class:&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#34;brush: csharp;&#34;&gt;public static class StyleNames&lt;br /&gt;{&lt;br /&gt;  public static string ButtonStyleName = &amp;ldquo;Some Hard To write style name&amp;rdquo;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The benefits of using this class instead of hard coded strings are:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;No need to avoid long meaningful names, cause you have auto complete built in the IDE.&lt;/li&gt;&lt;li&gt;The obvious: avoid type mistakes, and unexpected crashes.&lt;/li&gt;&lt;li&gt;Make your programmers less lazy, they&amp;rsquo;ll be able to change the resource name in a single place, and even his member name if needed, VS will rename it in all references and in XAML(VS 2010) (with a &amp;ldquo;Ctrl + .&amp;rdquo; after editing the member name).&lt;/li&gt;&lt;li&gt;If the style name is not readonly(like in my sample), I&amp;rsquo;m sure there is a simple way to support theming and dynamic style changing, by just assigning new names for all the resource names inside StyleNames class, and telling the app to do something that will reload all styles, I&amp;rsquo;m not sure about it, so don&amp;rsquo;t count on it.&lt;/li&gt;&lt;li&gt;No crashes of &amp;ldquo;could not find resource bla bla&amp;rdquo;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Here is the code after the use of static class:&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#34;brush: csharp;&#34;&gt;&amp;lt;Window x:Class=&amp;ldquo;How.MainWindow&amp;rdquo;&lt;br /&gt;    xmlns=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&lt;/a&gt;&lt;br /&gt;    xmlns:x=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&lt;/a&gt;&lt;br /&gt;    xmlns:local=&amp;ldquo;clr-namespace:How&amp;rdquo;&lt;br /&gt;    Title=&amp;ldquo;MainWindow&amp;rdquo; Height=&amp;ldquo;350&amp;rdquo; Width=&amp;ldquo;525&amp;rdquo;&amp;gt;&lt;br /&gt;&amp;lt;Window.Resources&amp;gt;&lt;br /&gt;    &amp;lt;Style TargetType=&amp;quot;{x:Type Button}&amp;rdquo; x:Key=&amp;quot;{x:Static local:StyleNames.ButtonStyleName}&amp;quot;&amp;gt;&lt;br /&gt;        &amp;lt;Setter Property=&amp;ldquo;Margin&amp;rdquo; Value=&amp;ldquo;30&amp;rdquo;/&amp;gt;&lt;br /&gt;        &amp;lt;Setter Property=&amp;ldquo;Height&amp;rdquo; Value=&amp;ldquo;30&amp;rdquo;/&amp;gt;&lt;br /&gt;        &amp;lt;Setter Property=&amp;ldquo;Width&amp;rdquo; Value=&amp;ldquo;200&amp;rdquo;/&amp;gt;&lt;br /&gt;    &amp;lt;/Style&amp;gt;&lt;br /&gt;&amp;lt;/Window.Resources&amp;gt;&lt;br /&gt;&amp;lt;StackPanel&amp;gt;&lt;br /&gt;        &amp;lt;Button Click=&amp;ldquo;Button_Click&amp;rdquo;&amp;gt;Click me to activate my style&amp;lt;/Button&amp;gt;&lt;br /&gt;    &amp;lt;Button Style=&amp;quot;{DynamicResource ResourceKey={x:Static local:StyleNames.ButtonStyleName}}&amp;rdquo;/&amp;gt;&lt;br /&gt;&amp;lt;/StackPanel&amp;gt;&lt;br /&gt;&amp;lt;/Window&amp;gt;&lt;br /&gt;&lt;br /&gt;private void Button_Click(object sender, RoutedEventArgs e)&lt;br /&gt;{&lt;br /&gt;  var button = sender as Button;&lt;br /&gt;  if (button != null)&lt;br /&gt;  {&lt;br /&gt;    button.Style = (Style)this.FindResource(StyleNames.ButtonStyleName);&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Enjoy :)&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
