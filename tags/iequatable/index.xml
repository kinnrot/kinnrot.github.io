<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>IEquatable on cdblg</title>
    <link>https://kinnrot.github.io/tags/iequatable/</link>
    <description>Recent content in IEquatable on cdblg</description>
    <generator>Hugo -- 0.155.3</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Jan 2011 14:47:00 -0800</lastBuildDate>
    <atom:link href="https://kinnrot.github.io/tags/iequatable/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WPF Binding and Why you should write defensive code.</title>
      <link>https://kinnrot.github.io/wpf-binding-and-why-you-should-write/</link>
      <pubDate>Wed, 05 Jan 2011 14:47:00 -0800</pubDate>
      <guid>https://kinnrot.github.io/wpf-binding-and-why-you-should-write/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m overriding equals and implementing IEquatable on some of my objects and bind them as an ObservableCollection to the UI.&lt;br /&gt;&lt;br /&gt;Here is a sample: (ugly code do not use)&lt;br /&gt;&lt;br /&gt;&lt;pre class=&#34;brush: csharp;&#34;&gt;&amp;lt;Window x:Class=&amp;ldquo;BindingToItemsWithIEquality.MainWindow&amp;rdquo;&lt;br /&gt;        xmlns=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;quot;&lt;/a&gt;&lt;br /&gt;        xmlns:x=&amp;ldquo;&lt;a href=&#34;http://schemas.microsoft.com/winfx/2006/xaml%22&#34;&gt;http://schemas.microsoft.com/winfx/2006/xaml&amp;quot;&lt;/a&gt;&lt;br /&gt;        xmlns:local=&amp;ldquo;clr-namespace:BindingToItemsWithIEquality&amp;rdquo;&lt;br /&gt;        Title=&amp;ldquo;MainWindow&amp;rdquo; Height=&amp;ldquo;350&amp;rdquo; Width=&amp;ldquo;525&amp;rdquo;&lt;br /&gt;        &amp;gt;&lt;br /&gt;    &amp;lt;Window.DataContext&amp;gt;&lt;br /&gt;        &amp;lt;local:SomeContextWithCollection/&amp;gt;&lt;br /&gt;    &amp;lt;/Window.DataContext&amp;gt;&lt;br /&gt;    &amp;lt;StackPanel&amp;gt;&lt;br /&gt;        &amp;lt;ListBox DisplayMemberPath=&amp;ldquo;Name&amp;rdquo; ItemsSource=&amp;quot;{Binding Items}&amp;rdquo;/&amp;gt;&lt;br /&gt;        &amp;lt;Button Click=&amp;ldquo;Button_Click&amp;rdquo;&amp;gt;clear&amp;lt;/Button&amp;gt;&lt;br /&gt;    &amp;lt;/StackPanel&amp;gt;&lt;br /&gt;&amp;lt;/Window&amp;gt;&lt;br /&gt;&lt;br /&gt;//code behind&lt;br /&gt;private void Button_Click(object sender, RoutedEventArgs e)&lt;br /&gt;{&lt;br /&gt;  (this.DataContext as SomeContextWithCollection).Items.Clear();&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public class SomeContextWithCollection &lt;br /&gt;{&lt;br /&gt;    public ObservableCollection&amp;lt;SomeIEqutable&amp;gt; Items { get; set; }&lt;br /&gt;&lt;br /&gt;    public SomeContextWithCollection()&lt;br /&gt;    {&lt;br /&gt;      Items = new ObservableCollection&amp;lt;SomeIEqutable&amp;gt;();&lt;br /&gt;      Items.Add(new SomeIEqutable() { Name = &amp;ldquo;1&amp;rdquo; });&lt;br /&gt;      Items.Add(new SomeIEqutable() { Name = &amp;ldquo;2&amp;rdquo; });&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public class SomeIEqutable : IEquatable&amp;lt;SomeIEqutable&amp;gt;&lt;br /&gt;{&lt;br /&gt;  public string Name { get; set; }&lt;br /&gt;&lt;br /&gt;  public override bool Equals(object obj)&lt;br /&gt;  {&lt;br /&gt;    if (obj == null)&lt;br /&gt;    {&lt;br /&gt;      return false;&lt;br /&gt;    }&lt;br /&gt;          &lt;br /&gt;    return Equals((SomeIEqutable)obj);&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  public bool Equals(SomeIEqutable other)&lt;br /&gt;  {&lt;br /&gt;    if (object.ReferenceEquals(this, other))&lt;br /&gt;    {&lt;br /&gt;      return true;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    return Name == other.Name;&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  public override int GetHashCode()&lt;br /&gt;  {&lt;br /&gt;    return Name.GetHashCode();&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When calling collection.Clear() I get an invalid cast inside my equals method, when trying to cast to SomeIEquatable.&lt;br /&gt;&lt;br /&gt;This is pretty strange, object is not null and not SomeIEquatlabe, how did it get to my Equals?&lt;br /&gt;&lt;br /&gt;The answer is WPF, when working with binding and clearing a bounded collection WPF will compare his internal new MSInternal.NamedObject(named DisconnectedItem) to your SomeIEquatable object and will fail if you try to implicitly cast it to your type.&lt;br /&gt;&lt;br /&gt;The simple solution is to use the &amp;ldquo;as&amp;rdquo; keyword instead of cast.&lt;br /&gt;&lt;br /&gt;If my code didn&amp;rsquo;t smell from the start, I would never got to this dark place. But I&amp;rsquo;m glad it happened, now I have another excuse to write defensive code.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
