---
layout: post
title: WPF Binding and Why you should write defensive code.
date: '2011-01-05T14:47:00.000-08:00'
author: Chen Kinnrot
tags:
- Binding
- IEquatable
- WPF
modified_time: '2011-01-05T14:47:37.244-08:00'
blogger_id: tag:blogger.com,1999:blog-8908829452516573489.post-4994609083917309029
blogger_orig_url: http://kinnrot.blogspot.com/2011/01/wpf-binding-and-why-you-should-write.html
---

I'm overriding equals and implementing IEquatable on some of my objects and bind them as an ObservableCollection to the UI.<br /><br />Here is a sample: (ugly code do not use)<br /><br /><pre class="brush: csharp;">&lt;Window x:Class="BindingToItemsWithIEquality.MainWindow"<br />        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"<br />        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"<br />        xmlns:local="clr-namespace:BindingToItemsWithIEquality"<br />        Title="MainWindow" Height="350" Width="525"<br />        &gt;<br />    &lt;Window.DataContext&gt;<br />        &lt;local:SomeContextWithCollection/&gt;<br />    &lt;/Window.DataContext&gt;<br />    &lt;StackPanel&gt;<br />        &lt;ListBox DisplayMemberPath="Name" ItemsSource="{Binding Items}"/&gt;<br />        &lt;Button Click="Button_Click"&gt;clear&lt;/Button&gt;<br />    &lt;/StackPanel&gt;<br />&lt;/Window&gt;<br /><br />//code behind<br />private void Button_Click(object sender, RoutedEventArgs e)<br />{<br />  (this.DataContext as SomeContextWithCollection).Items.Clear();<br />}<br /><br />public class SomeContextWithCollection <br />{<br />    public ObservableCollection&lt;SomeIEqutable&gt; Items { get; set; }<br /><br />    public SomeContextWithCollection()<br />    {<br />      Items = new ObservableCollection&lt;SomeIEqutable&gt;();<br />      Items.Add(new SomeIEqutable() { Name = "1" });<br />      Items.Add(new SomeIEqutable() { Name = "2" });<br />    }<br />}<br /><br />public class SomeIEqutable : IEquatable&lt;SomeIEqutable&gt;<br />{<br />  public string Name { get; set; }<br /><br />  public override bool Equals(object obj)<br />  {<br />    if (obj == null)<br />    {<br />      return false;<br />    }<br />          <br />    return Equals((SomeIEqutable)obj);<br />  }<br /><br />  public bool Equals(SomeIEqutable other)<br />  {<br />    if (object.ReferenceEquals(this, other))<br />    {<br />      return true;<br />    }<br /><br />    return Name == other.Name;<br />  }<br /><br />  public override int GetHashCode()<br />  {<br />    return Name.GetHashCode();<br />  }<br />}<br /></pre><br />When calling collection.Clear() I get an invalid cast inside my equals method, when trying to cast to SomeIEquatable.<br /><br />This is pretty strange, object is not null and not SomeIEquatlabe, how did it get to my Equals?<br /><br />The answer is WPF, when working with binding and clearing a bounded collection WPF will compare his internal new MSInternal.NamedObject(named DisconnectedItem) to your SomeIEquatable object and will fail if you try to implicitly cast it to your type.<br /><br />The simple solution is to use the "as" keyword istead of cast.<br /><br />If my code didn't smell from the start, I would never got to this dark place. But I'm glad it happened, now I have another excuse to write defensive code.