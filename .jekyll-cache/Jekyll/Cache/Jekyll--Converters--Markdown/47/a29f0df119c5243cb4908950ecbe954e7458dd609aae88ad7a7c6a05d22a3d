I"<p>Recently I tried to find a nice code sample for how to pass complex type through WCF, inside the header,  meaning I want to send the client execution context to the server side.<br /><br />All of the samples passes strings or uses custom header that needs to write and read the object manually, I didnâ€™t like it.<br /><br />So I wrote one and itâ€™s working!<br />&lt;div id="stackstack-5443871"&gt;&lt;/div&gt;All you need is 2 classes, and one is just a factory for the other, very simple:<br /><br />&lt;pre class="brush: csharp;"&gt;using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Runtime.Serialization;<br />using System.ServiceModel;<br />using System.ServiceModel.Channels;<br />using System.ServiceModel.Dispatcher;<br />using System.Text;<br /><br />namespace debugniv.ComplexTypeOverWcf<br />{<br />  class HeaderHandler : IDispatchMessageInspector, IClientMessageInspector<br />  {<br />    #region Implementation of IDispatchMessageInspector<br /><br />    public object AfterReceiveRequest(ref Message request, IClientChannel channel, InstanceContext instanceContext)<br />    {<br />      // Read the complex type from header<br />      var headerIndex = request.Headers.FindHeader(typeof(MyHeader).Name, typeof(MyHeader).Namespace);<br /><br />      if (headerIndex &gt;= 0) // found!<br />      {<br />        var serializer = GenerateDataContractSerializer&lt;MyHeader&gt;();<br />        var myHeader = request.Headers.GetHeader&lt;MyHeader&gt;(headerIndex, serializer);<br />        // here you can do something with your header like push it to a global per request context.<br />      }<br />      return null;<br />    }<br /><br />    public void BeforeSendReply(ref Message reply, object correlationState)<br />    {<br />      // nothing here<br />    }<br /><br />    #endregion<br /><br />    #region Implementation of IClientMessageInspector<br /><br />    public object BeforeSendRequest(ref Message request, IClientChannel channel)<br />    {<br />      var myHeader = GetMyHeader();<br />      request.Headers.Add(myHeader);<br />    }<br /><br />    public void AfterReceiveReply(ref Message reply, object correlationState)<br />    {<br />      // nothing to do here<br />    }<br /><br />    #endregion<br /><br />    private DataContractSerializer GenerateDataContractSerializer&lt;T&gt;()<br />    {<br />      return new DataContractSerializer(typeof(T), typeof(T).Name, typeof(T).Namespace, GetKnownTypes());<br />    }<br /><br />    private IEnumerable&lt;Type&gt; GetKnownTypes()<br />    {<br />      // here return all your types inside the header<br />      yield return typeof(MyHeader);<br />      yield return typeof(SubType);<br />    }<br /><br />    private MessageHeader GetMyHeader()<br />    {<br />      var data = new MyHeader();<br />      var serializer = GenerateDataContractSerializer&lt;MyHeader&gt;();<br />      return MessageHeader.CreateHeader(data.GetType().Name, data.GetType().Namespace, data, serializer);<br />    }<br /><br /><br />  }<br /><br />  // this is the header <br />  internal class MyHeader<br />  {<br />    public SubType InternalData { get; set; }<br />  }<br /><br />  internal class SubType<br />  {<br />  }<br />}<br /><br />&lt;/pre&gt;<br />The second thing youâ€™ll need is to attach this stuff to your service and proxy, here is one way to do this<br /><br />&lt;pre class="brush: csharp;"&gt;using System;<br />using System.ServiceModel.Configuration;<br /><br />namespace debugniv.ComplexTypeOverWcf<br />{<br />  public class HeaderExtensionElement : BehaviorExtensionElement<br />  {<br /><br />    public override Type BehaviorType<br />    {<br />      get { return typeof (HeaderHandler); }<br />    }<br /><br />    protected override object CreateBehavior()<br />    {<br />      return new HeaderHandler();<br />    }<br />  }<br />}<br />&lt;/pre&gt;<br />In you config file add the following <br /><extensions><br />  <behaviorExtensions><br />   <add name="customEndpointBehavior" type="your extension type name"></add><br />  </behaviorExtensions></extensions></p>
:ET