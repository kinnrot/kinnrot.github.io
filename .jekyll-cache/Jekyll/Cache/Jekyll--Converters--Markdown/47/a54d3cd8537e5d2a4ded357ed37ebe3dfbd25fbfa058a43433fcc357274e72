I"<p>Iâ€™m overriding equals and implementing IEquatable on some of my objects and bind them as an ObservableCollection to the UI.<br /><br />Here is a sample: (ugly code do not use)<br /><br />&lt;pre class="brush: csharp;"&gt;&lt;Window x:Class=â€BindingToItemsWithIEquality.MainWindowâ€<br />        xmlns=â€http://schemas.microsoft.com/winfx/2006/xaml/presentationâ€<br />        xmlns:x=â€http://schemas.microsoft.com/winfx/2006/xamlâ€<br />        xmlns:local=â€clr-namespace:BindingToItemsWithIEqualityâ€<br />        Title=â€MainWindowâ€ Height=â€350â€ Width=â€525â€<br />        &gt;<br />    &lt;Window.DataContext&gt;<br />        &lt;local:SomeContextWithCollection/&gt;<br />    &lt;/Window.DataContext&gt;<br />    &lt;StackPanel&gt;<br />        &lt;ListBox DisplayMemberPath=â€Nameâ€ ItemsSource=â€{Binding Items}â€/&gt;<br />        &lt;Button Click=â€Button_Clickâ€&gt;clear&lt;/Button&gt;<br />    &lt;/StackPanel&gt;<br />&lt;/Window&gt;<br /><br />//code behind<br />private void Button_Click(object sender, RoutedEventArgs e)<br />{<br />  (this.DataContext as SomeContextWithCollection).Items.Clear();<br />}<br /><br />public class SomeContextWithCollection <br />{<br />    public ObservableCollection&lt;SomeIEqutable&gt; Items { get; set; }<br /><br />    public SomeContextWithCollection()<br />    {<br />      Items = new ObservableCollection&lt;SomeIEqutable&gt;();<br />      Items.Add(new SomeIEqutable() { Name = â€œ1â€ });<br />      Items.Add(new SomeIEqutable() { Name = â€œ2â€ });<br />    }<br />}<br /><br />public class SomeIEqutable : IEquatable&lt;SomeIEqutable&gt;<br />{<br />  public string Name { get; set; }<br /><br />  public override bool Equals(object obj)<br />  {<br />    if (obj == null)<br />    {<br />      return false;<br />    }<br />          <br />    return Equals((SomeIEqutable)obj);<br />  }<br /><br />  public bool Equals(SomeIEqutable other)<br />  {<br />    if (object.ReferenceEquals(this, other))<br />    {<br />      return true;<br />    }<br /><br />    return Name == other.Name;<br />  }<br /><br />  public override int GetHashCode()<br />  {<br />    return Name.GetHashCode();<br />  }<br />}<br />&lt;/pre&gt;<br />When calling collection.Clear() I get an invalid cast inside my equals method, when trying to cast to SomeIEquatable.<br /><br />This is pretty strange, object is not null and not SomeIEquatlabe, how did it get to my Equals?<br /><br />The answer is WPF, when working with binding and clearing a bounded collection WPF will compare his internal new MSInternal.NamedObject(named DisconnectedItem) to your SomeIEquatable object and will fail if you try to implicitly cast it to your type.<br /><br />The simple solution is to use the â€œasâ€ keyword istead of cast.<br /><br />If my code didnâ€™t smell from the start, I would never got to this dark place. But Iâ€™m glad it happened, now I have another excuse to write defensive code.</p>
:ET